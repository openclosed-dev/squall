/*
 * Copyright 2022-2023 The Squall Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dev.openclosed.squall.parser.basic;

import dev.openclosed.squall.api.spec.Expression;
import dev.openclosed.squall.api.spec.ExpressionFactory;

/**
 * Token generated by the tokenizer.
 */
public interface Token {

    Token EOI = () -> TokenType.EOI;

    TokenType type();

    default String text() {
        throw new UnsupportedOperationException("no text");
    }

    default Object value() {
        return text();
    }

    default String toIdentifier() {
        return value().toString();
    }

    default Expression toLiteral(ExpressionFactory factory) {
        throw new UnsupportedOperationException("not a literal");
    }

    default boolean isPrimary() {
        return type().isPrimary();
    }

    default boolean isKeyword() {
        return false;
    }

    default boolean isFunction() {
        return false;
    }

    default boolean isIdentifier(IdentifierType type) {
        return false;
    }

    default boolean isComment() {
        return type() == TokenType.LINE_COMMENT || type() == TokenType.BLOCK_COMMENT;
    }

    default boolean isLiteral() {
        return false;
    }

    default boolean isSameAs(Object obj) {
        return this == obj;
    }

    // As operators

    default boolean isUnaryOperator() {
        return unaryOperatorGroup() != null;
    }

    default OperatorGroup unaryOperatorGroup() {
        return null;
    }

    default boolean isBinaryOperator() {
        return binaryOperatorGroup() != null;
    }

    default OperatorGroup binaryOperatorGroup() {
        return null;
    }
}

record BitStringToken(CharSequence wholeText, int start, int end) implements Token {

    @Override
    public TokenType type() {
        return TokenType.BIT_STRING;
    }

    @Override
    public String text() {
        return wholeText.subSequence(start, end).toString();
    }

    @Override
    public Object value() {
        return wholeText.subSequence(start + 2, end - 1).toString();
    }

    @Override
    public Expression toLiteral(ExpressionFactory factory) {
        return factory.bitString(value().toString());
    }

    @Override
    public boolean isLiteral() {
        return true;
    }
}

record CommentToken(TokenType type, CharSequence wholeText, int start, int end) implements Token {

    int length() {
        return end() - start();
    }

    @Override
    public String text() {
        return wholeText.subSequence(start, end).toString();
    }
}

record IdentifierToken(String text) implements Token {

    @Override
    public TokenType type() {
        return TokenType.IDENTIFIER;
    }

    @Override
    public Object value() {
        return text().toLowerCase();
    }

    @Override
    public boolean isIdentifier(IdentifierType type) {
        return true;
    }
}

record NumberToken(TokenType type, String text, Number value) implements Token {

    @Override
    public Expression toLiteral(ExpressionFactory factory) {
        return factory.number(text());
    }

    @Override
    public boolean isLiteral() {
        return true;
    }
}

record QuotedIdentifierToken(
    CharSequence wholeText,
    int start,
    int end)
    implements Token {

    @Override
    public TokenType type() {
        return TokenType.QUOTED_IDENTIFIER;
    }

    @Override
    public String text() {
        return wholeText.subSequence(start, end).toString();
    }

    @Override
    public Object value() {
        return wholeText.subSequence(start + 1, end - 1).toString();
    }

    @Override
    public boolean isIdentifier(IdentifierType type) {
        return true;
    }
}

record StringToken(CharSequence wholeText, int start, int end, String value) implements Token {

    @Override
    public TokenType type() {
        return TokenType.STRING;
    }

    @Override
    public String text() {
        return wholeText.subSequence(start, end).toString();
    }

    @Override
    public Expression toLiteral(ExpressionFactory factory) {
        return factory.string(value());
    }

    @Override
    public boolean isLiteral() {
        return true;
    }
}

